Index: hornetq-server/src/main/java/org/hornetq/core/server/impl/QuorumManager.java
===================================================================
--- hornetq-server/src/main/java/org/hornetq/core/server/impl/QuorumManager.java	(revision dc47801bcd843e8b5eb6eb78519d87449fd50965)
+++ hornetq-server/src/main/java/org/hornetq/core/server/cluster/qourum/QuorumManager.java	(revision )
@@ -10,22 +10,25 @@
  * implied.  See the License for the specific language governing
  * permissions and limitations under the License.
  */
-package org.hornetq.core.server.impl;
+package org.hornetq.core.server.cluster.qourum;
 
+import java.lang.reflect.Array;
 import java.util.Collection;
+import java.util.HashMap;
 import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.hornetq.api.core.DiscoveryGroupConfiguration;
 import org.hornetq.api.core.HornetQException;
 import org.hornetq.api.core.HornetQExceptionType;
 import org.hornetq.api.core.Pair;
 import org.hornetq.api.core.TransportConfiguration;
-import org.hornetq.api.core.client.ClientSession;
-import org.hornetq.api.core.client.ClientSessionFactory;
 import org.hornetq.api.core.client.ClusterTopologyListener;
 import org.hornetq.api.core.client.HornetQClient;
 import org.hornetq.api.core.client.ServerLocator;
@@ -33,12 +36,21 @@
 import org.hornetq.api.core.client.TopologyMember;
 import org.hornetq.core.client.impl.ClientSessionFactoryInternal;
 import org.hornetq.core.client.impl.ServerLocatorImpl;
+import org.hornetq.core.client.impl.ServerLocatorInternal;
 import org.hornetq.core.client.impl.Topology;
 import org.hornetq.core.client.impl.TopologyMemberImpl;
+import org.hornetq.core.config.ClusterConnectionConfiguration;
+import org.hornetq.core.config.ConfigurationUtils;
+import org.hornetq.core.protocol.ServerPacketDecoder;
 import org.hornetq.core.protocol.core.CoreRemotingConnection;
 import org.hornetq.core.protocol.core.impl.wireformat.ReplicationLiveIsStoppingMessage.LiveStopping;
+import org.hornetq.core.server.HornetQMessageBundle;
+import org.hornetq.core.server.HornetQServer;
 import org.hornetq.core.server.HornetQServerLogger;
+import org.hornetq.core.server.LiveNodeLocator;
 import org.hornetq.core.server.NodeManager;
+import org.hornetq.core.server.impl.HornetQServerImpl;
+import org.hornetq.core.server.impl.ReplicationError;
 
 /**
  * Manages a quorum of servers used to determine whether a given server is running or not.
@@ -66,136 +78,86 @@
  */
 public final class QuorumManager implements SessionFailureListener, ClusterTopologyListener
 {
-   private String targetServerID = "";
-   private final ExecutorService executor;
+   private Map<String, Quorum> quorums = new HashMap<>();
+   private HornetQServer server;
    private final String serverIdentity;
-   private CountDownLatch latch;
-   private volatile BACKUP_ACTIVATION signal;
-   private ClientSessionFactoryInternal sessionFactory;
    private final Topology topology;
    private CoreRemotingConnection connection;
+   private ServerLocatorInternal serverLocator;
+   private boolean started = false;
+   private CountDownLatch connectedLatch;
 
-   /**
-    * safety parameter to make _sure_ we get out of await()
-    */
-   private static final int LATCH_TIMEOUT = 30;
-   private static final int RECONNECT_ATTEMPTS = 5;
-
-   private final Object decisionGuard = new Object();
-   private final NodeManager nodeManager;
-   private final ServerLocator serverLocator;
-   private final ScheduledExecutorService scheduledPool;
-
-   /**
-    * This is a safety net in case the live sends the first {@link ReplicationLiveIsStoppingMessage}
-    * with code {@link LiveStopping#STOP_CALLED} and crashes before sending the second with
-    * {@link LiveStopping#FAIL_OVER}.
-    * <p/>
-    * If the second message does come within this dead line, we fail over anyway.
-    */
-   public static final int WAIT_TIME_AFTER_FIRST_LIVE_STOPPING_MSG = 60;
-
-   public QuorumManager(ServerLocator serverLocator, ExecutorService executor, ScheduledExecutorService scheduledPool,
-                        String identity, NodeManager nodeManager)
+   public QuorumManager(HornetQServer server, String identity)
    {
+      this.server = server;
       this.serverIdentity = identity;
-      this.executor = executor;
-      this.scheduledPool = scheduledPool;
-      this.latch = new CountDownLatch(1);
-      this.nodeManager = nodeManager;
-      this.serverLocator = serverLocator;
       topology = serverLocator.getTopology();
    }
 
-   @Override
-   public void nodeUP(TopologyMember topologyMember, boolean last)
+   public void start() throws Exception
    {
-      //noop
-   }
-
-   @Override
-   public void nodeDown(long eventUID, String nodeID)
+      synchronized (this)
-   {
+      {
-      if (targetServerID.equals(nodeID))
+         connectedLatch = new CountDownLatch(1);
+         //we use the cluster connection configuration to connect to the cluster to find the live node we want to
+         //connect to.
+         ClusterConnectionConfiguration config =
+            ConfigurationUtils.getReplicationClusterConfiguration(server.getConfiguration());
+         if (serverLocator != null)
-      {
+         {
-         decideOnAction();
+            serverLocator.close();
-      }
+         }
+         serverLocator = getLocator(config);
-   }
+      }
+      //if the cluster isn't available we want to hang around until it is
+      serverLocator.setReconnectAttempts(-1);
+      serverLocator.setInitialConnectAttempts(-1);
+      //this is used for replication so need to use the server packet decoder
+      serverLocator.setPacketDecoder(ServerPacketDecoder.INSTANCE);
+      //receive topology updates
+      serverLocator.addClusterTopologyListener(this);
 
-   public void setLiveID(String liveID)
-   {
-      targetServerID = liveID;
-      nodeManager.setNodeID(liveID);
-      //now we are replicating we can start waiting for disconnect notifications so we can fail over
-      sessionFactory.addFailureListener(this);
-   }
+      started = true;
 
-   private boolean isLiveDown()
-   {
-      Collection<TopologyMemberImpl> nodes = topology.getMembers();
-      Collection<ServerLocator> locatorsList = new LinkedList<ServerLocator>();
-      AtomicInteger pingCount = new AtomicInteger(0);
-      int total = 0;
-      for (TopologyMemberImpl tm : nodes)
-         if (useIt(tm))
-            total++;
+      server.getExecutorFactory().getExecutor().execute(new ConnectRunnable());
 
-      if (total < 1)
-         return true;
+   }
 
-      final CountDownLatch voteLatch = new CountDownLatch(total);
-      try
-      {
-         for (TopologyMemberImpl tm : nodes)
-         {
-            Pair<TransportConfiguration, TransportConfiguration> pair = tm.getConnector();
 
-            TransportConfiguration serverTC = pair.getA();
-            if (useIt(tm))
+   public void registerQuorum(Quorum quorum)
-            {
+   {
-               ServerLocatorImpl locator = (ServerLocatorImpl) HornetQClient.createServerLocatorWithoutHA(serverTC);
-               locatorsList.add(locator);
-               executor.submit(new QuorumVoteServerConnect(voteLatch, total, pingCount, locator, serverTC));
+      quorums.put(quorum.getName(), quorum);
-            }
+   }
-         }
 
-         try
+   public void unRegisterQuorum(Quorum quorum)
-         {
+   {
-            voteLatch.await(LATCH_TIMEOUT, TimeUnit.SECONDS);
+      quorums.remove(quorum.getName());
-         }
+   }
-         catch (InterruptedException interruption)
+   @Override
+   public void nodeUP(TopologyMember topologyMember, boolean last)
-         {
+   {
-            // No-op. The best the quorum can do now is to return the latest number it has
+      //noop
-         }
+   }
-         // -1: because the live server is not being filtered out.
-         boolean vote = nodeIsDown(total, pingCount.get());
-         HornetQServerLogger.LOGGER.trace("quorum vote is liveIsDown=" + vote + ", count=" + pingCount);
-         return vote;
-      }
-      finally
+
+   @Override
+   public void nodeDown(long eventUID, String nodeID)
-      {
+   {
-         for (ServerLocator locator : locatorsList)
+      if (targetServerID.equals(nodeID))
-         {
+      {
-            try
+         for (Quorum quorum : quorums.values())
-            {
+         {
-               locator.close();
+            quorum.decideOnAction(topology);
-            }
+         }
-            catch (Exception e)
-            {
-               // no-op
-            }
-         }
+      }
+   }
-      }
-   }
 
-   /**
-    * @param tm
-    * @return
-    */
-   private boolean useIt(TopologyMemberImpl tm)
+   public void setLiveID(String liveID)
    {
-      return tm.getLive() != null && !targetServerID.equals(tm.getLive().getName());
+      for (Quorum quorum : quorums.values())
+      {
+         quorum.liveIDSet(liveID);
-   }
+      }
+   }
 
    @Override
    public String toString()
@@ -203,225 +165,113 @@
       return QuorumManager.class.getSimpleName() + "(server=" + serverIdentity + ")";
    }
 
-   /**
-    * Decides whether the server is to be considered down or not.
-    *
-    * @param totalServers
-    * @param reachedServers
-    * @return
-    */
-   private static boolean nodeIsDown(int totalServers, int reachedServers)
-   { // at least half of the servers were reached
-      return reachedServers * 2 >= totalServers - 1;
+   @Override
+   public void beforeReconnect(HornetQException exception)
+   {
+      //noop
    }
 
-   public void notifyRegistrationFailed()
+   @Override
+   public void connectionFailed(HornetQException exception, boolean failedOver)
    {
-      signal = BACKUP_ACTIVATION.FAILURE_REPLICATING;
-      latch.countDown();
+      for (Quorum quorum : quorums.values())
+      {
+         quorum.decideOnAction(topology);
-   }
+      }
+   }
 
-   public void notifyAlreadyReplicating()
+   private void removeListener()
    {
-      signal = BACKUP_ACTIVATION.ALREADY_REPLICATING;
-      latch.countDown();
+      serverLocator.removeClusterTopologyListener(this);
+      if (connection != null)
+         connection.removeFailureListener(this);
    }
 
+
+
    /**
-    * Attempts to connect to a given server.
+    * @param liveConnection
     */
-   private static class QuorumVoteServerConnect implements Runnable
+   public void addAsFailureListenerOf(CoreRemotingConnection liveConnection)
    {
-      private final ServerLocatorImpl locator;
-      private final CountDownLatch latch;
-      private final AtomicInteger count;
-      private final TransportConfiguration tc;
-      private final int total;
-
-      public QuorumVoteServerConnect(CountDownLatch latch, int total, AtomicInteger count,
-                                     ServerLocatorImpl serverLocator,
-                                     TransportConfiguration serverTC)
-      {
-         this.total = total;
-         this.locator = serverLocator;
-         this.latch = latch;
-         this.count = count;
-         this.tc = serverTC;
+      this.connection = liveConnection;
+      connection.addFailureListener(this);
+      //connection.addCloseListener(this);
-      }
+   }
 
-
-      @Override
-      public void run()
+   private ServerLocatorInternal getLocator(ClusterConnectionConfiguration config) throws HornetQException
-      {
+   {
-         locator.setReconnectAttempts(0);
+      ServerLocatorInternal locator;
+      if (config.getDiscoveryGroupName() != null)
+      {
+         DiscoveryGroupConfiguration dg = server.getConfiguration().getDiscoveryGroupConfigurations().get(config.getDiscoveryGroupName());
 
-         final ClientSessionFactory sessionFactory;
-         ClientSession session;
-         try
+         if (dg == null)
          {
-            sessionFactory = locator.createSessionFactory(tc);
-            if (sessionFactory != null)
-            {
-               session = sessionFactory.createSession();
-               if (session != null)
-               {
-                  if (nodeIsDown(total, count.incrementAndGet()))
-                  {
-                     while (latch.getCount() > 0)
-                     {
-                        latch.countDown();
+            throw HornetQMessageBundle.BUNDLE.noDiscoveryGroupFound(dg);
-                     }
+         }
+         locator = (ServerLocatorInternal) HornetQClient.createServerLocatorWithHA(dg);
-                  }
+      }
-                  session.close();
-                  sessionFactory.close();
-               }
-            }
-         }
-         catch (Exception e)
+      else
-         {
+      {
-            // no-op
+         TransportConfiguration[] tcConfigs = config.getStaticConnectors() != null ? connectorNameListToArray(config.getStaticConnectors())
+            : null;
+
+         locator = (ServerLocatorInternal) HornetQClient.createServerLocatorWithHA(tcConfigs);
-         }
+      }
-         finally
-         {
-            latch.countDown();
-            locator.close();
+      return locator;
-         }
+   }
-      }
-   }
 
-   @Override
-   public void beforeReconnect(HornetQException exception)
-   {
-      //noop
-   }
 
-   @Override
-   public void connectionFailed(HornetQException exception, boolean failedOver)
+   private TransportConfiguration[] connectorNameListToArray(final List<String> connectorNames)
    {
-      decideOnAction();
-   }
+      TransportConfiguration[] tcConfigs = (TransportConfiguration[]) Array.newInstance(TransportConfiguration.class,
+                                                                                        connectorNames.size());
+      int count = 0;
+      for (String connectorName : connectorNames)
+      {
+         TransportConfiguration connector = server.getConfiguration().getConnectorConfigurations().get(connectorName);
 
-   private void decideOnAction()
+         if (connector == null)
-   {
+         {
-      //we may get called via multiple paths so need to guard
-      synchronized (decisionGuard)
-      {
-         if (signal == BACKUP_ACTIVATION.FAIL_OVER)
-         {
-            return;
+            HornetQServerLogger.LOGGER.bridgeNoConnector(connectorName);
+
+            return null;
          }
-         if (!isLiveDown())
-         {
-            try
-            {
-               // no point in repeating all the reconnection logic
-               sessionFactory.connect(RECONNECT_ATTEMPTS, false);
-               return;
-            }
-            catch (HornetQException e)
-            {
-               if (e.getType() != HornetQExceptionType.NOT_CONNECTED)
-                  HornetQServerLogger.LOGGER.errorReConnecting(e);
-            }
-         }
-         // live is assumed to be down, backup fails-over
-         signal = BACKUP_ACTIVATION.FAIL_OVER;
-      }
-      latch.countDown();
-   }
 
-   enum BACKUP_ACTIVATION
-   {
-      FAIL_OVER, FAILURE_REPLICATING, ALREADY_REPLICATING, STOP;
+         tcConfigs[count++] = connector;
-   }
+      }
 
-   /**
-    * Called by the replicating backup (i.e. "SharedNothing" backup) to wait for the signal to
-    * fail-over or to stop.
-    *
-    * @return signal, indicating whether to stop or to fail-over
-    */
-   public BACKUP_ACTIVATION waitForStatusChange()
-   {
-      try
-      {
-         latch.await();
+      return tcConfigs;
-      }
+   }
-      catch (InterruptedException e)
-      {
-         return BACKUP_ACTIVATION.STOP;
-      }
-      return signal;
-   }
 
-   /**
-    * Cause the Activation thread to exit and the server to be stopped.
-    *
-    * @param explicitSignal the state we want to set the quorum manager to return
-    */
-   public synchronized void causeExit(BACKUP_ACTIVATION explicitSignal)
+   public void addClusterTopologyListener(ClusterTopologyListener listener)
    {
-      removeListener();
-      this.signal = explicitSignal;
-      latch.countDown();
+      serverLocator.addClusterTopologyListener(listener);
    }
 
-   private void removeListener()
+   public void awaitConnectionToCluster() throws InterruptedException
    {
-      serverLocator.removeClusterTopologyListener(this);
-      if (connection != null)
-         connection.removeFailureListener(this);
+      connectedLatch.await();
    }
 
-   /**
-    * Releases the latch, causing the backup activation thread to fail-over.
-    * <p/>
-    * The use case is for when the 'live' has an orderly shutdown, in which case it informs the
-    * backup that it should fail-over.
-    */
-   public synchronized void failOver(LiveStopping finalMessage)
+
+   private final class ConnectRunnable implements Runnable
    {
-      removeListener();
-      signal = BACKUP_ACTIVATION.FAIL_OVER;
-      if (finalMessage == LiveStopping.FAIL_OVER)
-      {
-         latch.countDown();
-      }
-      if (finalMessage == LiveStopping.STOP_CALLED)
-      {
-         final CountDownLatch localLatch = latch;
-         scheduledPool.schedule(new Runnable()
-         {
-            @Override
-            public void run()
-            {
+      @Override
+      public void run()
+      {
-               localLatch.countDown();
-            }
-
-         }, WAIT_TIME_AFTER_FIRST_LIVE_STOPPING_MSG, TimeUnit.SECONDS);
-      }
-   }
-
-   /**
-    * @param sessionFactory the session factory used to connect to the live server
-    */
-   public void setSessionFactory(ClientSessionFactoryInternal sessionFactory)
+         try
-   {
+         {
-      this.sessionFactory = sessionFactory;
+            serverLocator.connect();
+            connectedLatch.countDown();
-   }
+         }
-
-   /**
-    * @param liveConnection
-    */
-   public void addAsFailureListenerOf(CoreRemotingConnection liveConnection)
+         catch (HornetQException e)
-   {
+         {
-      this.connection = liveConnection;
-      connection.addFailureListener(this);
-      //connection.addCloseListener(this);
+            if (!started)
+               return;
+            server.getScheduledPool().schedule(this, serverLocator.getRetryInterval(), TimeUnit.MILLISECONDS);
-   }
+         }
-
-   public synchronized void reset()
-   {
-      latch = new CountDownLatch(1);
+      }
    }
 }
Index: tests/integration-tests/src/test/java/org/hornetq/tests/integration/cluster/distribution/ClusterTestBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- tests/integration-tests/src/test/java/org/hornetq/tests/integration/cluster/distribution/ClusterTestBase.java	(revision dc47801bcd843e8b5eb6eb78519d87449fd50965)
+++ tests/integration-tests/src/test/java/org/hornetq/tests/integration/cluster/distribution/ClusterTestBase.java	(revision )
@@ -63,7 +63,7 @@
 import org.hornetq.core.server.group.GroupingHandler;
 import org.hornetq.core.server.group.impl.GroupingHandlerConfiguration;
 import org.hornetq.core.server.impl.InVMNodeManager;
-import org.hornetq.core.server.impl.QuorumManager;
+import org.hornetq.core.server.cluster.qourum.QuorumManager;
 import org.hornetq.tests.integration.IntegrationTestLogger;
 import org.hornetq.tests.util.ServiceTestBase;
 import org.hornetq.tests.util.UnitTestCase;
Index: hornetq-server/src/main/java/org/hornetq/core/server/cluster/qourum/Quorum.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hornetq-server/src/main/java/org/hornetq/core/server/cluster/qourum/Quorum.java	(revision )
+++ hornetq-server/src/main/java/org/hornetq/core/server/cluster/qourum/Quorum.java	(revision )
@@ -0,0 +1,16 @@
+package org.hornetq.core.server.cluster.qourum;
+
+import org.hornetq.core.client.impl.Topology;
+
+/**
+ * @author Clebert Suconic
+ */
+
+public interface Quorum
+{
+   String getName();
+
+   void decideOnAction(Topology topology);
+
+   void liveIDSet(String liveID);
+}
Index: hornetq-server/src/main/java/org/hornetq/core/server/LiveNodeLocator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hornetq-server/src/main/java/org/hornetq/core/server/LiveNodeLocator.java	(revision dc47801bcd843e8b5eb6eb78519d87449fd50965)
+++ hornetq-server/src/main/java/org/hornetq/core/server/LiveNodeLocator.java	(revision )
@@ -18,7 +18,8 @@
 import org.hornetq.api.core.TransportConfiguration;
 import org.hornetq.api.core.client.ClusterTopologyListener;
 import org.hornetq.core.client.impl.ServerLocatorInternal;
-import org.hornetq.core.server.impl.QuorumManager;
+import org.hornetq.core.server.cluster.qourum.QuorumManager;
+import org.hornetq.core.server.cluster.qourum.SharedNothingBackupQuorum;
 
 /**
  * A class that will locate a particular live server running in a cluster. How this live is chosen
@@ -31,11 +32,11 @@
  */
 public abstract class LiveNodeLocator implements ClusterTopologyListener
 {
-   private QuorumManager quorumManager;
+   private SharedNothingBackupQuorum backupQuorum;
 
-   public LiveNodeLocator(QuorumManager quorumManager)
+   public LiveNodeLocator(SharedNothingBackupQuorum backupQuorum)
    {
-      this.quorumManager = quorumManager;
+      this.backupQuorum = backupQuorum;
    }
 
    /**
@@ -70,15 +71,15 @@
     */
    public void notifyRegistrationFailed(boolean alreadyReplicating)
    {
-      if (quorumManager != null)
+      if (backupQuorum != null)
       {
          if (alreadyReplicating)
          {
-            quorumManager.notifyAlreadyReplicating();
+            backupQuorum.notifyAlreadyReplicating();
          }
          else
          {
-            quorumManager.notifyRegistrationFailed();
+            backupQuorum.notifyRegistrationFailed();
          }
       }
    }
Index: hornetq-server/src/main/java/org/hornetq/core/server/cluster/qourum/SharedNothingBackupQuorum.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hornetq-server/src/main/java/org/hornetq/core/server/cluster/qourum/SharedNothingBackupQuorum.java	(revision )
+++ hornetq-server/src/main/java/org/hornetq/core/server/cluster/qourum/SharedNothingBackupQuorum.java	(revision )
@@ -0,0 +1,296 @@
+/*
+ * Copyright 2005-2014 Red Hat, Inc.
+ * Red Hat licenses this file to you under the Apache License, version
+ * 2.0 (the "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+ * implied.  See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package org.hornetq.core.server.cluster.qourum;
+
+import java.util.Collection;
+import java.util.LinkedList;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.hornetq.api.core.HornetQException;
+import org.hornetq.api.core.HornetQExceptionType;
+import org.hornetq.api.core.Pair;
+import org.hornetq.api.core.TransportConfiguration;
+import org.hornetq.api.core.client.HornetQClient;
+import org.hornetq.api.core.client.ServerLocator;
+import org.hornetq.core.client.impl.ClientSessionFactoryInternal;
+import org.hornetq.core.client.impl.ServerLocatorImpl;
+import org.hornetq.core.client.impl.ServerLocatorInternal;
+import org.hornetq.core.client.impl.Topology;
+import org.hornetq.core.client.impl.TopologyMemberImpl;
+import org.hornetq.core.protocol.core.impl.wireformat.ReplicationLiveIsStoppingMessage;
+import org.hornetq.core.server.HornetQServerLogger;
+import org.hornetq.core.server.NodeManager;
+
+/**
+ * @author Clebert Suconic
+ */
+
+public class SharedNothingBackupQuorum implements Quorum
+{
+   private String targetServerID = "";
+   private final NodeManager nodeManager;
+   private final ExecutorService executor;
+   private final ScheduledExecutorService scheduledPool;
+   private CountDownLatch latch;
+   private ClientSessionFactoryInternal sessionFactory;
+
+   /**
+    * This is a safety net in case the live sends the first {@link ReplicationLiveIsStoppingMessage}
+    * with code {@link org.hornetq.core.protocol.core.impl.wireformat.ReplicationLiveIsStoppingMessage.LiveStopping#STOP_CALLED} and crashes before sending the second with
+    * {@link org.hornetq.core.protocol.core.impl.wireformat.ReplicationLiveIsStoppingMessage.LiveStopping#FAIL_OVER}.
+    * <p/>
+    * If the second message does come within this dead line, we fail over anyway.
+    */
+   public static final int WAIT_TIME_AFTER_FIRST_LIVE_STOPPING_MSG = 60;
+
+   public SharedNothingBackupQuorum(NodeManager nodeManager, ExecutorService threadPool, ScheduledExecutorService scheduledPool)
+   {
+      this.executor = threadPool;
+      this.scheduledPool = scheduledPool;
+      this.latch = new CountDownLatch(1);
+      this.nodeManager = nodeManager;
+   }
+
+   public enum BACKUP_ACTIVATION
+   {
+      FAIL_OVER, FAILURE_REPLICATING, ALREADY_REPLICATING, STOP;
+   }
+
+   private volatile BACKUP_ACTIVATION signal;
+
+   /**
+    * safety parameter to make _sure_ we get out of await()
+    */
+   private static final int LATCH_TIMEOUT = 30;
+
+   private static final int RECONNECT_ATTEMPTS = 5;
+
+   private final Object decisionGuard = new Object();
+
+   /**
+    * Decides whether the server is to be considered down or not.
+    *
+    * @param totalServers
+    * @param reachedServers
+    * @return
+    */
+   public static boolean nodeIsDown(int totalServers, int reachedServers)
+   { // at least half of the servers were reached
+      return reachedServers * 2 >= totalServers - 1;
+   }
+
+   /**
+    * @param tm
+    * @return
+    */
+   private boolean useIt(TopologyMemberImpl tm)
+   {
+      return tm.getLive() != null && !targetServerID.equals(tm.getLive().getName());
+   }
+
+   @Override
+   public String getName()
+   {
+      return "SharedNothingBackupQuorum";
+   }
+
+   public void decideOnAction(Topology topology)
+   {
+      //we may get called via multiple paths so need to guard
+      synchronized (decisionGuard)
+      {
+         if (signal == BACKUP_ACTIVATION.FAIL_OVER)
+         {
+            return;
+         }
+         if (!isLiveDown(topology))
+         {
+            try
+            {
+               // no point in repeating all the reconnection logic
+               sessionFactory.connect(RECONNECT_ATTEMPTS, false);
+               return;
+            }
+            catch (HornetQException e)
+            {
+               if (e.getType() != HornetQExceptionType.NOT_CONNECTED)
+                  HornetQServerLogger.LOGGER.errorReConnecting(e);
+            }
+         }
+         // live is assumed to be down, backup fails-over
+         signal = BACKUP_ACTIVATION.FAIL_OVER;
+      }
+      latch.countDown();
+   }
+
+   @Override
+   public void liveIDSet(String liveID)
+   {
+      targetServerID = liveID;
+      nodeManager.setNodeID(liveID);
+      //now we are replicating we can start waiting for disconnect notifications so we can fail over
+      sessionFactory.addFailureListener(this);
+   }
+
+
+   /**
+    * @param sessionFactory the session factory used to connect to the live server
+    */
+   public void setSessionFactory(ClientSessionFactoryInternal sessionFactory)
+   {
+      this.sessionFactory = sessionFactory;
+   }
+
+   /**
+    * Releases the latch, causing the backup activation thread to fail-over.
+    * <p/>
+    * The use case is for when the 'live' has an orderly shutdown, in which case it informs the
+    * backup that it should fail-over.
+    */
+   public synchronized void failOver(ReplicationLiveIsStoppingMessage.LiveStopping finalMessage)
+   {
+      removeListener();
+      signal = BACKUP_ACTIVATION.FAIL_OVER;
+      if (finalMessage == ReplicationLiveIsStoppingMessage.LiveStopping.FAIL_OVER)
+      {
+         latch.countDown();
+      }
+      if (finalMessage == ReplicationLiveIsStoppingMessage.LiveStopping.STOP_CALLED)
+      {
+         final CountDownLatch localLatch = latch;
+         scheduledPool.schedule(new Runnable()
+         {
+            @Override
+            public void run()
+            {
+               localLatch.countDown();
+            }
+
+         }, WAIT_TIME_AFTER_FIRST_LIVE_STOPPING_MSG, TimeUnit.SECONDS);
+      }
+   }
+
+
+
+   public void notifyRegistrationFailed()
+   {
+      signal = BACKUP_ACTIVATION.FAILURE_REPLICATING;
+      latch.countDown();
+   }
+
+   public void notifyAlreadyReplicating()
+   {
+      signal = BACKUP_ACTIVATION.ALREADY_REPLICATING;
+      latch.countDown();
+   }
+
+   /**
+    * Called by the replicating backup (i.e. "SharedNothing" backup) to wait for the signal to
+    * fail-over or to stop.
+    *
+    * @return signal, indicating whether to stop or to fail-over
+    */
+   public BACKUP_ACTIVATION waitForStatusChange()
+   {
+      try
+      {
+         latch.await();
+      }
+      catch (InterruptedException e)
+      {
+         return BACKUP_ACTIVATION.STOP;
+      }
+      return signal;
+   }
+
+
+   /**
+    * Cause the Activation thread to exit and the server to be stopped.
+    *
+    * @param explicitSignal the state we want to set the quorum manager to return
+    */
+   public synchronized void causeExit(BACKUP_ACTIVATION explicitSignal)
+   {
+      removeListener();
+      this.signal = explicitSignal;
+      latch.countDown();
+   }
+
+   public synchronized void reset()
+   {
+      latch = new CountDownLatch(1);
+   }
+
+   private boolean isLiveDown(Topology topology)
+   {
+      Collection<TopologyMemberImpl> nodes = topology.getMembers();
+      Collection<ServerLocator> locatorsList = new LinkedList<ServerLocator>();
+      AtomicInteger pingCount = new AtomicInteger(0);
+      int total = 0;
+      for (TopologyMemberImpl tm : nodes)
+         if (useIt(tm))
+            total++;
+
+      if (total < 1)
+         return true;
+
+      final CountDownLatch voteLatch = new CountDownLatch(total);
+      try
+      {
+         for (TopologyMemberImpl tm : nodes)
+         {
+            Pair<TransportConfiguration, TransportConfiguration> pair = tm.getConnector();
+
+            TransportConfiguration serverTC = pair.getA();
+            if (useIt(tm))
+            {
+               ServerLocatorImpl locator = (ServerLocatorImpl) HornetQClient.createServerLocatorWithoutHA(serverTC);
+               locatorsList.add(locator);
+               executor.submit(new QuorumVoteServerConnect(voteLatch, total, pingCount, locator, serverTC));
+            }
+         }
+
+         try
+         {
+            voteLatch.await(LATCH_TIMEOUT, TimeUnit.SECONDS);
+         }
+         catch (InterruptedException interruption)
+         {
+            // No-op. The best the quorum can do now is to return the latest number it has
+         }
+         // -1: because the live server is not being filtered out.
+         boolean vote = nodeIsDown(total, pingCount.get());
+         HornetQServerLogger.LOGGER.trace("quorum vote is liveIsDown=" + vote + ", count=" + pingCount);
+         return vote;
+      }
+      finally
+      {
+         for (ServerLocator locator : locatorsList)
+         {
+            try
+            {
+               locator.close();
+            }
+            catch (Exception e)
+            {
+               // no-op
+            }
+         }
+      }
+   }
+}
Index: hornetq-server/src/main/java/org/hornetq/core/replication/ReplicationEndpoint.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hornetq-server/src/main/java/org/hornetq/core/replication/ReplicationEndpoint.java	(revision dc47801bcd843e8b5eb6eb78519d87449fd50965)
+++ hornetq-server/src/main/java/org/hornetq/core/replication/ReplicationEndpoint.java	(revision )
@@ -73,7 +73,7 @@
 import org.hornetq.core.server.HornetQServerLogger;
 import org.hornetq.core.server.ServerMessage;
 import org.hornetq.core.server.impl.HornetQServerImpl;
-import org.hornetq.core.server.impl.QuorumManager;
+import org.hornetq.core.server.cluster.qourum.QuorumManager;
 
 /**
  * Handles all the synchronization necessary for replication on the backup side (that is the
Index: hornetq-server/src/main/java/org/hornetq/core/server/impl/AnyLiveNodeLocatorForReplication.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hornetq-server/src/main/java/org/hornetq/core/server/impl/AnyLiveNodeLocatorForReplication.java	(revision dc47801bcd843e8b5eb6eb78519d87449fd50965)
+++ hornetq-server/src/main/java/org/hornetq/core/server/impl/AnyLiveNodeLocatorForReplication.java	(revision )
@@ -26,6 +26,8 @@
 import org.hornetq.api.core.TransportConfiguration;
 import org.hornetq.api.core.client.TopologyMember;
 import org.hornetq.core.server.LiveNodeLocator;
+import org.hornetq.core.server.cluster.qourum.QuorumManager;
+import org.hornetq.core.server.cluster.qourum.SharedNothingBackupQuorum;
 
 /**
  * This implementation looks for any available live node, once tried with no success it is marked as
@@ -43,9 +45,9 @@
 
    private String nodeID;
 
-   public AnyLiveNodeLocatorForReplication(QuorumManager quorumManager, HornetQServerImpl server)
+   public AnyLiveNodeLocatorForReplication(SharedNothingBackupQuorum backupQuorum, HornetQServerImpl server)
    {
-      super(quorumManager);
+      super(backupQuorum);
       this.server = server;
    }
 
Index: hornetq-server/src/main/java/org/hornetq/core/server/cluster/qourum/QuorumVoteServerConnect.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hornetq-server/src/main/java/org/hornetq/core/server/cluster/qourum/QuorumVoteServerConnect.java	(revision )
+++ hornetq-server/src/main/java/org/hornetq/core/server/cluster/qourum/QuorumVoteServerConnect.java	(revision )
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2005-2014 Red Hat, Inc.
+ * Red Hat licenses this file to you under the Apache License, version
+ * 2.0 (the "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+ * implied.  See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package org.hornetq.core.server.cluster.qourum;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.hornetq.api.core.TransportConfiguration;
+import org.hornetq.api.core.client.ClientSession;
+import org.hornetq.api.core.client.ClientSessionFactory;
+import org.hornetq.core.client.impl.ServerLocatorImpl;
+
+/**
+ * Attempts to connect to a given server.
+ */
+class QuorumVoteServerConnect implements Runnable
+{
+   private final ServerLocatorImpl locator;
+   private final CountDownLatch latch;
+   private final AtomicInteger count;
+   private final TransportConfiguration tc;
+   private final int total;
+
+   public QuorumVoteServerConnect(CountDownLatch latch, int total, AtomicInteger count,
+                                  ServerLocatorImpl serverLocator,
+                                  TransportConfiguration serverTC)
+   {
+      this.total = total;
+      this.locator = serverLocator;
+      this.latch = latch;
+      this.count = count;
+      this.tc = serverTC;
+   }
+
+
+
+
+   @Override
+   public void run()
+   {
+      locator.setReconnectAttempts(0);
+
+      final ClientSessionFactory sessionFactory;
+      ClientSession session;
+      try
+      {
+         sessionFactory = locator.createSessionFactory(tc);
+         if (sessionFactory != null)
+         {
+            session = sessionFactory.createSession();
+            if (session != null)
+            {
+               if (SharedNothingBackupQuorum.nodeIsDown(total, count.incrementAndGet()))
+               {
+                  while (latch.getCount() > 0)
+                  {
+                     latch.countDown();
+                  }
+               }
+               session.close();
+               sessionFactory.close();
+            }
+         }
+      }
+      catch (Exception e)
+      {
+         // no-op
+      }
+      finally
+      {
+         latch.countDown();
+         locator.close();
+      }
+   }
+}
Index: hornetq-server/src/main/java/org/hornetq/core/server/impl/HornetQServerImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hornetq-server/src/main/java/org/hornetq/core/server/impl/HornetQServerImpl.java	(revision dc47801bcd843e8b5eb6eb78519d87449fd50965)
+++ hornetq-server/src/main/java/org/hornetq/core/server/impl/HornetQServerImpl.java	(revision )
@@ -133,11 +133,13 @@
 import org.hornetq.core.server.cluster.ClusterConnection;
 import org.hornetq.core.server.cluster.ClusterManager;
 import org.hornetq.core.server.cluster.Transformer;
+import org.hornetq.core.server.cluster.qourum.QuorumManager;
+import org.hornetq.core.server.cluster.qourum.SharedNothingBackupQuorum;
 import org.hornetq.core.server.group.GroupingHandler;
 import org.hornetq.core.server.group.impl.GroupingHandlerConfiguration;
 import org.hornetq.core.server.group.impl.LocalGroupingHandler;
 import org.hornetq.core.server.group.impl.RemoteGroupingHandler;
-import org.hornetq.core.server.impl.QuorumManager.BACKUP_ACTIVATION;
+import org.hornetq.core.server.cluster.qourum.SharedNothingBackupQuorum.BACKUP_ACTIVATION;
 import org.hornetq.core.server.management.ManagementService;
 import org.hornetq.core.server.management.impl.ManagementServiceImpl;
 import org.hornetq.core.settings.HierarchicalRepository;
@@ -159,9 +161,9 @@
 import org.hornetq.utils.SecurityFormatter;
 import org.hornetq.utils.VersionLoader;
 
-import static org.hornetq.core.server.impl.QuorumManager.BACKUP_ACTIVATION.FAILURE_REPLICATING;
-import static org.hornetq.core.server.impl.QuorumManager.BACKUP_ACTIVATION.FAIL_OVER;
-import static org.hornetq.core.server.impl.QuorumManager.BACKUP_ACTIVATION.STOP;
+import static org.hornetq.core.server.cluster.qourum.SharedNothingBackupQuorum.BACKUP_ACTIVATION.FAILURE_REPLICATING;
+import static org.hornetq.core.server.cluster.qourum.SharedNothingBackupQuorum.BACKUP_ACTIVATION.FAIL_OVER;
+import static org.hornetq.core.server.cluster.qourum.SharedNothingBackupQuorum.BACKUP_ACTIVATION.STOP;
 
 /**
  * The HornetQ server implementation
@@ -2532,7 +2534,7 @@
 
    private final class SharedNothingBackupActivation implements Activation
    {
-      private volatile ServerLocatorInternal serverLocator0;
+      SharedNothingBackupQuorum backupQuorum;
       private volatile QuorumManager quorumManager;
       private final boolean attemptFailBack;
       private String nodeID;
@@ -2560,21 +2562,7 @@
             {
                if (closed)
                   return;
-               //we use the cluster connection configuration to connect to the cluster to find the live node we want to
-               //connect to.
-               ClusterConnectionConfiguration config =
-                  ConfigurationUtils.getReplicationClusterConfiguration(configuration);
-               if (serverLocator0 != null)
-               {
-                  serverLocator0.close();
-               }
+            }
-               serverLocator0 = getLocator(config);
-            }
-            //if the cluster isn't available we want to hang around until it is
-            serverLocator0.setReconnectAttempts(-1);
-            serverLocator0.setInitialConnectAttempts(-1);
-            //this is used for replication so need to use the server packet decoder
-            serverLocator0.setPacketDecoder(ServerPacketDecoder.INSTANCE);
 
             if (!initialisePart1())
                return;
@@ -2583,31 +2571,20 @@
             {
                if (closed)
                   return;
-               quorumManager = new QuorumManager(serverLocator0, threadPool, scheduledPool, getIdentity(), nodeManager);
-               serverLocator0.addClusterTopologyListener(quorumManager);
+               quorumManager = new QuorumManager(HornetQServerImpl.this, getIdentity());
+               quorumManager.start();
+               backupQuorum = new SharedNothingBackupQuorum(nodeManager, threadPool, scheduledPool);
+               quorumManager.registerQuorum(backupQuorum);
             }
 
             //use a Node Locator to connect to the cluster
             LiveNodeLocator nodeLocator = configuration.getBackupGroupName() == null ?
-               new AnyLiveNodeLocatorForReplication(quorumManager, HornetQServerImpl.this) :
-               new NamedLiveNodeLocatorForReplication(configuration.getBackupGroupName(), quorumManager);
-            serverLocator0.addClusterTopologyListener(nodeLocator);
-            do
-            {
-               try
-               {
-                  nodeLocator.connectToCluster(serverLocator0);
-                  break;
-               }
-               catch (HornetQException e)
-               {
-                  if (closed)
-                     return;
-                  Thread.sleep(serverLocator0.getRetryInterval());
-               }
-            } while (true);
+               new AnyLiveNodeLocatorForReplication(backupQuorum, HornetQServerImpl.this) :
+               new NamedLiveNodeLocatorForReplication(configuration.getBackupGroupName(), backupQuorum);
+            quorumManager.addClusterTopologyListener(nodeLocator);
+            quorumManager.awaitConnectionToCluster();
 
-            serverLocator0.addIncomingInterceptor(new ReplicationError(HornetQServerImpl.this, nodeLocator));
+            quorumManager.addIncomingInterceptor(new ReplicationError(HornetQServerImpl.this, nodeLocator));
 
             // nodeManager.startBackup();
 
@@ -2676,7 +2653,7 @@
                 * process again on the next live server.  All the action happens inside
                 * {@link QuorumManager}
                 */
-               signal = quorumManager.waitForStatusChange();
+               signal = backupQuorum.waitForStatusChange();
                /**
                 * replicationEndpoint will be holding lots of open files. Make sure they get
                 * closed/sync'ed.
@@ -2712,7 +2689,7 @@
                //ok, this live is no good, let's reset and try again
                //close this session factory, we're done with it
                liveServerSessionFactory.close();
-               quorumManager.reset();
+               backupQuorum.reset();
                if (replicationEndpoint.getChannel() != null)
                {
                   replicationEndpoint.getChannel().close();
@@ -2758,8 +2735,8 @@
       {
          synchronized (this)
          {
-            if (quorumManager != null)
-               quorumManager.causeExit(STOP);
+            if (backupQuorum != null)
+               backupQuorum.causeExit(STOP);
             if (serverLocator0 != null)
             {
                serverLocator0.close();
@@ -2808,11 +2785,11 @@
       {
          if (finalMessage == null)
          {
-            quorumManager.causeExit(FAILURE_REPLICATING);
+            backupQuorum.causeExit(FAILURE_REPLICATING);
          }
          else
          {
-            quorumManager.failOver(finalMessage);
+            backupQuorum.failOver(finalMessage);
          }
       }
 
@@ -2825,7 +2802,7 @@
             {
                //we should only try once, if its not there we should move on.
                liveServerSessionFactory.setReconnectAttempts(1);
-               quorumManager.setSessionFactory(liveServerSessionFactory);
+               backupQuorum.setSessionFactory(liveServerSessionFactory);
                //get the connection and request replication to live
                CoreRemotingConnection liveConnection = (CoreRemotingConnection)liveServerSessionFactory.getConnection();
                quorumManager.addAsFailureListenerOf(liveConnection);
@@ -2839,7 +2816,7 @@
             {
                //we shouldn't stop the server just mark the connector as tried and unavailable
                HornetQServerLogger.LOGGER.replicationStartProblem(e);
-               quorumManager.causeExit(FAILURE_REPLICATING);
+               backupQuorum.causeExit(FAILURE_REPLICATING);
             }
          }
 
Index: hornetq-server/src/main/java/org/hornetq/core/server/impl/NamedLiveNodeLocatorForReplication.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hornetq-server/src/main/java/org/hornetq/core/server/impl/NamedLiveNodeLocatorForReplication.java	(revision dc47801bcd843e8b5eb6eb78519d87449fd50965)
+++ hornetq-server/src/main/java/org/hornetq/core/server/impl/NamedLiveNodeLocatorForReplication.java	(revision )
@@ -23,6 +23,8 @@
 import org.hornetq.api.core.TransportConfiguration;
 import org.hornetq.api.core.client.TopologyMember;
 import org.hornetq.core.server.LiveNodeLocator;
+import org.hornetq.core.server.cluster.qourum.QuorumManager;
+import org.hornetq.core.server.cluster.qourum.SharedNothingBackupQuorum;
 
 /**
  * NamedLiveNodeLocatorForReplication looks for a live server in the cluster with a specific backupGroupName
@@ -39,7 +41,7 @@
 
    private String nodeID;
 
-   public NamedLiveNodeLocatorForReplication(String backupGroupName, QuorumManager quorumManager)
+   public NamedLiveNodeLocatorForReplication(String backupGroupName, SharedNothingBackupQuorum quorumManager)
    {
       super(quorumManager);
       this.backupGroupName = backupGroupName;
